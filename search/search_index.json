{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GeneSpeak \u00b6 A library to encode text as DNA and decode DNA to text. GeneSpeak allows you to encode regular text as DNA using base-pairs ( A , T , G , C ) and convert back to the original text. Text encoding is done for both ascii and utf-8 characters based on the strategy keyword argument. Background \u00b6 A DNA molucule consists of a double-helix, where each strand is composed of a series of bases from the following four types: Adenine ( A ) Cytosine ( C ) Guanine ( G ) Thymine ( T ) Adenine pairs with thymine, and cytosine pairs with guanine. A \u2013 T C \u2013 G Source: https://www.genome.gov/genetics-glossary/acgt Installation \u00b6 You can install the library via pip or conda . Install with pip pip install genespeak Install with conda conda install -c conda-forge genespeak Usage \u00b6 import genespeak as gp print ( f ' { gp . __name__ } version: { gp . __version__ } ' ) schema = \"ATCG\" # (1) strategy = \"ascii\" # (2) text = \"Hello World!\" dna = gp . text_to_dna ( text , schema = schema , strategy = strategy ) text_from_dna = gp . dna_to_text ( dna , schema = schema , strategy = strategy ) print ( f 'Text: { text } \\n Encoded DNA: { dna } \\n Decoded Text: { text_from_dna } \\n ' ) The schema parameter is used to determine how the text-to-dna conversion will be encoded. There are 24 possible values for schema: ACTG , AGCT , TACG , CATG , etc. The strategy parameter determines whether to treat the text as ascii-only ( strategy=\"ascii\" ) or as utf-8 ( strategy=\"utf-8\" ). For non-english text, or text with emojis, the utf-8 strategy must be used. Output genespeak version: 0 .0.5 Text: Hello World! Encoded DNA: TACATCTTTCGATCGATCGGACAATTTGTCGGTGACTCGATCTAACAT Decoded Text: Hello World!","title":"Home"},{"location":"#genespeak","text":"A library to encode text as DNA and decode DNA to text. GeneSpeak allows you to encode regular text as DNA using base-pairs ( A , T , G , C ) and convert back to the original text. Text encoding is done for both ascii and utf-8 characters based on the strategy keyword argument.","title":"GeneSpeak"},{"location":"#background","text":"A DNA molucule consists of a double-helix, where each strand is composed of a series of bases from the following four types: Adenine ( A ) Cytosine ( C ) Guanine ( G ) Thymine ( T ) Adenine pairs with thymine, and cytosine pairs with guanine. A \u2013 T C \u2013 G Source: https://www.genome.gov/genetics-glossary/acgt","title":"Background"},{"location":"#installation","text":"You can install the library via pip or conda . Install with pip pip install genespeak Install with conda conda install -c conda-forge genespeak","title":"Installation"},{"location":"#usage","text":"import genespeak as gp print ( f ' { gp . __name__ } version: { gp . __version__ } ' ) schema = \"ATCG\" # (1) strategy = \"ascii\" # (2) text = \"Hello World!\" dna = gp . text_to_dna ( text , schema = schema , strategy = strategy ) text_from_dna = gp . dna_to_text ( dna , schema = schema , strategy = strategy ) print ( f 'Text: { text } \\n Encoded DNA: { dna } \\n Decoded Text: { text_from_dna } \\n ' ) The schema parameter is used to determine how the text-to-dna conversion will be encoded. There are 24 possible values for schema: ACTG , AGCT , TACG , CATG , etc. The strategy parameter determines whether to treat the text as ascii-only ( strategy=\"ascii\" ) or as utf-8 ( strategy=\"utf-8\" ). For non-english text, or text with emojis, the utf-8 strategy must be used. Output genespeak version: 0 .0.5 Text: Hello World! Encoded DNA: TACATCTTTCGATCGATCGGACAATTTGTCGGTGACTCGATCTAACAT Decoded Text: Hello World!","title":"Usage"},{"location":"api/converters/","text":"Converters \u00b6 Class Converter \u00b6 Bases: object Source code in genespeak/converters.py class Converter ( object ): # The Converter API will enforce the use of text-encoding strategy names # with hyphens when applicable: # - example: \"utf-8\" instead of \"utf8\". # This makes sure of conveying that to the users. strategy_names = [ s . replace ( \"utf\" , \"utf-\" ) for s in AVAILABLE_STRATEGY_NAMES ] strategies = TextEncodingStrategies () encoder : DNABaseEncoder def __init__ ( self , schema : str = \"AGCT\" , binary_string_length : int = 8 , strategy : str = \"ascii\" , ): self . encoder = DNABaseEncoder ( schema = schema , binary_string_length = binary_string_length ) self . strategy = self . get_strategy ( strategy_name = strategy ) def __repr__ ( self ): kwargs = dict ( schema = self . encoder . schema , binary_string_length = self . encoder . binary_string_length , strategy = self . strategy . name , ) kwargs_string = \", \" . join ([ f \" { k } = { v } \" for k , v in kwargs . items ()]) classname = self . __class__ . __name__ return f \" { classname } ( { kwargs_string } )\" def get_encoded_text ( self , text : str ) -> List [ int ]: \"\"\"Encodes each character of the text and returns a list. The encoding strategy is picked from the ``Converter.strategy``. \"\"\" text = str ( text ) encoded_chr_list = [ ord ( x ) for x in text ] return encoded_chr_list def get_decoded_text ( self , encoded_chr_list : List [ int ], as_list : bool = False ) -> Union [ List [ str ], str ]: \"\"\"Decodes each character from an encoded-character-list (``encoded_chr_list``) and returns a either a string (if ``as_list = False``) or a list of decoded strings (if ``as_list = True``). The encoding/decoding strategy is picked from the ``Converter.strategy``. \"\"\" if not ( as_list ): text = \"\" . join ( chr ( x ) for x in encoded_chr_list ) else : text = [ chr ( x ) for x in encoded_chr_list ] return text def dec_to_bin ( self , decimal_numbers : List [ int ]) -> List [ int ]: \"\"\"Returns a list of binary numbers for a given list of POSITIVE decimal integers. \"\"\" return [ int ( bin ( x )[ 2 :]) for x in decimal_numbers ] def convert_info_to_2Nbit_binary ( self , text : str , length2N : int = 8 ) -> List [ str ]: # convert to list of ascii / encoded-characters text_encoded_chr = self . get_encoded_text ( text ) # convert to binary list of int text_encoded_bin = self . dec_to_bin ( text_encoded_chr ) # convert to list of binary-2N-bit str (just 2N digits: 0 or 1) text_encoded_bin_2Nbit = [ str ( x ) . zfill ( length2N ) for x in text_encoded_bin ] return text_encoded_bin_2Nbit def get_bin2N_to_bin2 ( self , str_bin2N : str ) -> List [ str ]: str_bin2_list = self . split_text ( str_bin2N , length = 2 ) return str_bin2_list def get_bin2_to_bin2N ( self , str_bin2 : str , length2N : int = 8 ) -> List [ str ]: str_bin2N_list = self . split_text ( str_bin2 , length = length2N ) return str_bin2N_list def split_text ( self , text : str , length = 4 ) -> List [ str ]: split_text_list = list ( map ( \"\" . join , zip ( * [ iter ( text )] * length ))) return split_text_list def convert_to_dnabase ( self , bin_str_list : List [ str ], strategy : Optional [ str ] = None ) -> Tuple [ List [ str ], List [ str ]]: # A list of two-character binary strings dnabase_bin2 : List [ str ] = [] # Determine text-encoding-strategy if strategy is None : strategy = self . get_strategy ( strategy_name = strategy ) # type: ignore else : strategy = self . strategy for x_bin2N in bin_str_list : dnabase_bin2 += self . get_bin2N_to_bin2 ( x_bin2N ) dnabase_chr = [ self . encoder . bin2chr . get ( x_bin2 ) for x_bin2 in dnabase_bin2 ] return ( dnabase_chr , dnabase_bin2 ) # type: ignore def get_strategy ( self , strategy_name : str = \"ascii\" ): \"\"\"Returns strategy based on name.\"\"\" return set_strategy ( strategy_name = strategy_name ) dec_to_bin ( decimal_numbers ) \u00b6 Returns a list of binary numbers for a given list of POSITIVE decimal integers. Source code in genespeak/converters.py def dec_to_bin ( self , decimal_numbers : List [ int ]) -> List [ int ]: \"\"\"Returns a list of binary numbers for a given list of POSITIVE decimal integers. \"\"\" return [ int ( bin ( x )[ 2 :]) for x in decimal_numbers ] get_decoded_text ( encoded_chr_list , as_list = False ) \u00b6 Decodes each character from an encoded-character-list ( encoded_chr_list ) and returns a either a string (if as_list = False ) or a list of decoded strings (if as_list = True ). The encoding/decoding strategy is picked from the Converter.strategy . Source code in genespeak/converters.py def get_decoded_text ( self , encoded_chr_list : List [ int ], as_list : bool = False ) -> Union [ List [ str ], str ]: \"\"\"Decodes each character from an encoded-character-list (``encoded_chr_list``) and returns a either a string (if ``as_list = False``) or a list of decoded strings (if ``as_list = True``). The encoding/decoding strategy is picked from the ``Converter.strategy``. \"\"\" if not ( as_list ): text = \"\" . join ( chr ( x ) for x in encoded_chr_list ) else : text = [ chr ( x ) for x in encoded_chr_list ] return text get_encoded_text ( text ) \u00b6 Encodes each character of the text and returns a list. The encoding strategy is picked from the Converter.strategy . Source code in genespeak/converters.py def get_encoded_text ( self , text : str ) -> List [ int ]: \"\"\"Encodes each character of the text and returns a list. The encoding strategy is picked from the ``Converter.strategy``. \"\"\" text = str ( text ) encoded_chr_list = [ ord ( x ) for x in text ] return encoded_chr_list get_strategy ( strategy_name = 'ascii' ) \u00b6 Returns strategy based on name. Source code in genespeak/converters.py def get_strategy ( self , strategy_name : str = \"ascii\" ): \"\"\"Returns strategy based on name.\"\"\" return set_strategy ( strategy_name = strategy_name ) Function set_converter \u00b6 Creates a Converter if no Converter is provided. Source code in genespeak/converters.py def set_converter ( schema : str = \"AGCT\" , binary_string_length : int = 8 , strategy : str = \"ascii\" , converter : Optional [ Converter ] = None , ) -> Converter : \"\"\"Creates a ``Converter`` if no ``Converter`` is provided.\"\"\" if ( converter is None ) or ( not isinstance ( converter , Converter )): converter = Converter ( schema = schema , binary_string_length = binary_string_length , strategy = strategy , ) return converter","title":"converter"},{"location":"api/converters/#converters","text":"","title":"Converters"},{"location":"api/converters/#class-converter","text":"Bases: object Source code in genespeak/converters.py class Converter ( object ): # The Converter API will enforce the use of text-encoding strategy names # with hyphens when applicable: # - example: \"utf-8\" instead of \"utf8\". # This makes sure of conveying that to the users. strategy_names = [ s . replace ( \"utf\" , \"utf-\" ) for s in AVAILABLE_STRATEGY_NAMES ] strategies = TextEncodingStrategies () encoder : DNABaseEncoder def __init__ ( self , schema : str = \"AGCT\" , binary_string_length : int = 8 , strategy : str = \"ascii\" , ): self . encoder = DNABaseEncoder ( schema = schema , binary_string_length = binary_string_length ) self . strategy = self . get_strategy ( strategy_name = strategy ) def __repr__ ( self ): kwargs = dict ( schema = self . encoder . schema , binary_string_length = self . encoder . binary_string_length , strategy = self . strategy . name , ) kwargs_string = \", \" . join ([ f \" { k } = { v } \" for k , v in kwargs . items ()]) classname = self . __class__ . __name__ return f \" { classname } ( { kwargs_string } )\" def get_encoded_text ( self , text : str ) -> List [ int ]: \"\"\"Encodes each character of the text and returns a list. The encoding strategy is picked from the ``Converter.strategy``. \"\"\" text = str ( text ) encoded_chr_list = [ ord ( x ) for x in text ] return encoded_chr_list def get_decoded_text ( self , encoded_chr_list : List [ int ], as_list : bool = False ) -> Union [ List [ str ], str ]: \"\"\"Decodes each character from an encoded-character-list (``encoded_chr_list``) and returns a either a string (if ``as_list = False``) or a list of decoded strings (if ``as_list = True``). The encoding/decoding strategy is picked from the ``Converter.strategy``. \"\"\" if not ( as_list ): text = \"\" . join ( chr ( x ) for x in encoded_chr_list ) else : text = [ chr ( x ) for x in encoded_chr_list ] return text def dec_to_bin ( self , decimal_numbers : List [ int ]) -> List [ int ]: \"\"\"Returns a list of binary numbers for a given list of POSITIVE decimal integers. \"\"\" return [ int ( bin ( x )[ 2 :]) for x in decimal_numbers ] def convert_info_to_2Nbit_binary ( self , text : str , length2N : int = 8 ) -> List [ str ]: # convert to list of ascii / encoded-characters text_encoded_chr = self . get_encoded_text ( text ) # convert to binary list of int text_encoded_bin = self . dec_to_bin ( text_encoded_chr ) # convert to list of binary-2N-bit str (just 2N digits: 0 or 1) text_encoded_bin_2Nbit = [ str ( x ) . zfill ( length2N ) for x in text_encoded_bin ] return text_encoded_bin_2Nbit def get_bin2N_to_bin2 ( self , str_bin2N : str ) -> List [ str ]: str_bin2_list = self . split_text ( str_bin2N , length = 2 ) return str_bin2_list def get_bin2_to_bin2N ( self , str_bin2 : str , length2N : int = 8 ) -> List [ str ]: str_bin2N_list = self . split_text ( str_bin2 , length = length2N ) return str_bin2N_list def split_text ( self , text : str , length = 4 ) -> List [ str ]: split_text_list = list ( map ( \"\" . join , zip ( * [ iter ( text )] * length ))) return split_text_list def convert_to_dnabase ( self , bin_str_list : List [ str ], strategy : Optional [ str ] = None ) -> Tuple [ List [ str ], List [ str ]]: # A list of two-character binary strings dnabase_bin2 : List [ str ] = [] # Determine text-encoding-strategy if strategy is None : strategy = self . get_strategy ( strategy_name = strategy ) # type: ignore else : strategy = self . strategy for x_bin2N in bin_str_list : dnabase_bin2 += self . get_bin2N_to_bin2 ( x_bin2N ) dnabase_chr = [ self . encoder . bin2chr . get ( x_bin2 ) for x_bin2 in dnabase_bin2 ] return ( dnabase_chr , dnabase_bin2 ) # type: ignore def get_strategy ( self , strategy_name : str = \"ascii\" ): \"\"\"Returns strategy based on name.\"\"\" return set_strategy ( strategy_name = strategy_name )","title":"Class Converter"},{"location":"api/converters/#genespeak.converters.Converter.dec_to_bin","text":"Returns a list of binary numbers for a given list of POSITIVE decimal integers. Source code in genespeak/converters.py def dec_to_bin ( self , decimal_numbers : List [ int ]) -> List [ int ]: \"\"\"Returns a list of binary numbers for a given list of POSITIVE decimal integers. \"\"\" return [ int ( bin ( x )[ 2 :]) for x in decimal_numbers ]","title":"dec_to_bin()"},{"location":"api/converters/#genespeak.converters.Converter.get_decoded_text","text":"Decodes each character from an encoded-character-list ( encoded_chr_list ) and returns a either a string (if as_list = False ) or a list of decoded strings (if as_list = True ). The encoding/decoding strategy is picked from the Converter.strategy . Source code in genespeak/converters.py def get_decoded_text ( self , encoded_chr_list : List [ int ], as_list : bool = False ) -> Union [ List [ str ], str ]: \"\"\"Decodes each character from an encoded-character-list (``encoded_chr_list``) and returns a either a string (if ``as_list = False``) or a list of decoded strings (if ``as_list = True``). The encoding/decoding strategy is picked from the ``Converter.strategy``. \"\"\" if not ( as_list ): text = \"\" . join ( chr ( x ) for x in encoded_chr_list ) else : text = [ chr ( x ) for x in encoded_chr_list ] return text","title":"get_decoded_text()"},{"location":"api/converters/#genespeak.converters.Converter.get_encoded_text","text":"Encodes each character of the text and returns a list. The encoding strategy is picked from the Converter.strategy . Source code in genespeak/converters.py def get_encoded_text ( self , text : str ) -> List [ int ]: \"\"\"Encodes each character of the text and returns a list. The encoding strategy is picked from the ``Converter.strategy``. \"\"\" text = str ( text ) encoded_chr_list = [ ord ( x ) for x in text ] return encoded_chr_list","title":"get_encoded_text()"},{"location":"api/converters/#genespeak.converters.Converter.get_strategy","text":"Returns strategy based on name. Source code in genespeak/converters.py def get_strategy ( self , strategy_name : str = \"ascii\" ): \"\"\"Returns strategy based on name.\"\"\" return set_strategy ( strategy_name = strategy_name )","title":"get_strategy()"},{"location":"api/converters/#function-set_converter","text":"Creates a Converter if no Converter is provided. Source code in genespeak/converters.py def set_converter ( schema : str = \"AGCT\" , binary_string_length : int = 8 , strategy : str = \"ascii\" , converter : Optional [ Converter ] = None , ) -> Converter : \"\"\"Creates a ``Converter`` if no ``Converter`` is provided.\"\"\" if ( converter is None ) or ( not isinstance ( converter , Converter )): converter = Converter ( schema = schema , binary_string_length = binary_string_length , strategy = strategy , ) return converter","title":"Function set_converter"},{"location":"api/core/","text":"Core \u00b6 Function text_to_dna \u00b6 Encodes text string into DNA string with dna-bases ( A , C , G , T ). Parameters: Name Type Description Default text str a string required schema str the conversion schema to use (default: AGCT ) 'AGCT' binary_string_length int the length of the binary-string during conversion (use 8 for strategy='ascii' and 24 for strategy='utf-8' ) 8 strategy str the text-encoding/decoding strategy to use (default: ascii ) (options: ascii , utf-8 ) 'ascii' converter Optional [ Converter ] optionally you can provide a converter ( genespeak.converter.Converter ) None Source code in genespeak/core.py def text_to_dna ( text : str , schema : str = \"AGCT\" , binary_string_length : int = 8 , strategy : str = \"ascii\" , converter : Optional [ Converter ] = None , ) -> str : \"\"\"Encodes text string into DNA string with dna-bases (``A``, ``C``, ``G``, ``T``). Arguments: text: a string schema: the conversion schema to use (default: ``AGCT``) binary_string_length: the length of the binary-string during conversion (use ``8`` for ``strategy='ascii'`` and ``24`` for ``strategy='utf-8'``) strategy: the text-encoding/decoding strategy to use (default: ``ascii``) (options: ``ascii``, ``utf-8``) converter: optionally you can provide a converter (``genespeak.converter.Converter``) \"\"\" if ( converter is None ) or ( not isinstance ( converter , Converter )): converter = Converter ( schema = schema , binary_string_length = binary_string_length , strategy = strategy , ) dnabase_chr : List [ str ] = [] text_encoded_bin2N = converter . convert_info_to_2Nbit_binary ( text , length2N = converter . strategy . binary_string_length ) dnabase_chr , _ = converter . convert_to_dnabase ( text_encoded_bin2N , strategy = converter . strategy . name ) text_as_dnabase = \"\" . join ( dnabase_chr ) return text_as_dnabase Function dna_to_text \u00b6 Decodes valid encoded DNA string back into the equivalent text string. Parameters: Name Type Description Default dna str a string of dna-base required schema str the conversion schema to use (default: AGCT ) 'AGCT' binary_string_length int the length of the binary-string during conversion (use 8 for strategy='ascii' and 24 for strategy='utf-8' ) 8 strategy str the text-encoding/decoding strategy to use (default: ascii ) (options: ascii , utf-8 ) 'ascii' converter Optional [ Converter ] optionally you can provide a converter ( genespeak.converter.Converter ) None Source code in genespeak/core.py def dna_to_text ( dna : str , schema : str = \"AGCT\" , binary_string_length : int = 8 , strategy : str = \"ascii\" , converter : Optional [ Converter ] = None , ) -> str : \"\"\"Decodes valid encoded DNA string back into the equivalent text string. Arguments: dna: a string of dna-base schema: the conversion schema to use (default: ``AGCT``) binary_string_length: the length of the binary-string during conversion (use ``8`` for ``strategy='ascii'`` and ``24`` for ``strategy='utf-8'``) strategy: the text-encoding/decoding strategy to use (default: ``ascii``) (options: ``ascii``, ``utf-8``) converter: optionally you can provide a converter (``genespeak.converter.Converter``) \"\"\" converter = set_converter ( schema = schema , binary_string_length = binary_string_length , strategy = strategy , converter = converter , ) dnabase_as_bin = converter . encoder . chr2bin dnabase_as_bin2 = [ dnabase_as_bin . get ( x_chr ) for x_chr in dna ] length2N = converter . strategy . binary_string_length dnabase_as_bin2N = converter . get_bin2_to_bin2N ( \"\" . join ( dnabase_as_bin2 ), length2N = length2N ) # type: ignore # num_digits = 2 # length of any('00', '01', '10', '11') # binary to decimal conversion: int(x, 2) dnabase_as_chr = [ chr ( int ( x , 2 )) for x in dnabase_as_bin2N ] dnabase_as_text = \"\" . join ( dnabase_as_chr ) return dnabase_as_text","title":"core"},{"location":"api/core/#core","text":"","title":"Core"},{"location":"api/core/#function-text_to_dna","text":"Encodes text string into DNA string with dna-bases ( A , C , G , T ). Parameters: Name Type Description Default text str a string required schema str the conversion schema to use (default: AGCT ) 'AGCT' binary_string_length int the length of the binary-string during conversion (use 8 for strategy='ascii' and 24 for strategy='utf-8' ) 8 strategy str the text-encoding/decoding strategy to use (default: ascii ) (options: ascii , utf-8 ) 'ascii' converter Optional [ Converter ] optionally you can provide a converter ( genespeak.converter.Converter ) None Source code in genespeak/core.py def text_to_dna ( text : str , schema : str = \"AGCT\" , binary_string_length : int = 8 , strategy : str = \"ascii\" , converter : Optional [ Converter ] = None , ) -> str : \"\"\"Encodes text string into DNA string with dna-bases (``A``, ``C``, ``G``, ``T``). Arguments: text: a string schema: the conversion schema to use (default: ``AGCT``) binary_string_length: the length of the binary-string during conversion (use ``8`` for ``strategy='ascii'`` and ``24`` for ``strategy='utf-8'``) strategy: the text-encoding/decoding strategy to use (default: ``ascii``) (options: ``ascii``, ``utf-8``) converter: optionally you can provide a converter (``genespeak.converter.Converter``) \"\"\" if ( converter is None ) or ( not isinstance ( converter , Converter )): converter = Converter ( schema = schema , binary_string_length = binary_string_length , strategy = strategy , ) dnabase_chr : List [ str ] = [] text_encoded_bin2N = converter . convert_info_to_2Nbit_binary ( text , length2N = converter . strategy . binary_string_length ) dnabase_chr , _ = converter . convert_to_dnabase ( text_encoded_bin2N , strategy = converter . strategy . name ) text_as_dnabase = \"\" . join ( dnabase_chr ) return text_as_dnabase","title":"Function text_to_dna"},{"location":"api/core/#function-dna_to_text","text":"Decodes valid encoded DNA string back into the equivalent text string. Parameters: Name Type Description Default dna str a string of dna-base required schema str the conversion schema to use (default: AGCT ) 'AGCT' binary_string_length int the length of the binary-string during conversion (use 8 for strategy='ascii' and 24 for strategy='utf-8' ) 8 strategy str the text-encoding/decoding strategy to use (default: ascii ) (options: ascii , utf-8 ) 'ascii' converter Optional [ Converter ] optionally you can provide a converter ( genespeak.converter.Converter ) None Source code in genespeak/core.py def dna_to_text ( dna : str , schema : str = \"AGCT\" , binary_string_length : int = 8 , strategy : str = \"ascii\" , converter : Optional [ Converter ] = None , ) -> str : \"\"\"Decodes valid encoded DNA string back into the equivalent text string. Arguments: dna: a string of dna-base schema: the conversion schema to use (default: ``AGCT``) binary_string_length: the length of the binary-string during conversion (use ``8`` for ``strategy='ascii'`` and ``24`` for ``strategy='utf-8'``) strategy: the text-encoding/decoding strategy to use (default: ``ascii``) (options: ``ascii``, ``utf-8``) converter: optionally you can provide a converter (``genespeak.converter.Converter``) \"\"\" converter = set_converter ( schema = schema , binary_string_length = binary_string_length , strategy = strategy , converter = converter , ) dnabase_as_bin = converter . encoder . chr2bin dnabase_as_bin2 = [ dnabase_as_bin . get ( x_chr ) for x_chr in dna ] length2N = converter . strategy . binary_string_length dnabase_as_bin2N = converter . get_bin2_to_bin2N ( \"\" . join ( dnabase_as_bin2 ), length2N = length2N ) # type: ignore # num_digits = 2 # length of any('00', '01', '10', '11') # binary to decimal conversion: int(x, 2) dnabase_as_chr = [ chr ( int ( x , 2 )) for x in dnabase_as_bin2N ] dnabase_as_text = \"\" . join ( dnabase_as_chr ) return dnabase_as_text","title":"Function dna_to_text"},{"location":"api/dna_encoders/","text":"DNA Encoders \u00b6 Class DNABaseEncoder \u00b6 Bases: object A BaseEncoder class for DNA. Parameters: Name Type Description Default dnabase_as_bin dnabase with char:binary mapping required dnabase_as_chr dnabase with binary:char mapping required schema str the dnabase-schema (default: \"ACGT\") 'AGCT' binary_string_length int the binary-string length to use (example: 01 \u2192 00000001 ) 8 from genespeak.utils import DNABaseEncoder encoder = DNABaseEncoder ( schema = \"ACGT\" ) print ( encoder . dnabase_as_chr ) # {'00':'A', '01':'C', '10':'G', '11':'T'} print ( encoder . dnabase_as_bin ) # {'A':'00', 'C':'01', 'G':'10', 'T':'11'} There are a total of 24 ( 4 x 3 x 2 x 1 = 4! ) possible schemas: ACGT , ACTG , AGCT , AGTC , ATGC , ATCG , GACT , GCAT , GCTA , AGCT , etc. Source code in genespeak/dna_encoders.py class DNABaseEncoder ( object ): \"\"\"A BaseEncoder class for DNA. Arguments: dnabase_as_bin: dnabase with char:binary mapping dnabase_as_chr: dnabase with binary:char mapping schema: the dnabase-schema (default: \"ACGT\") binary_string_length: the binary-string length to use (example: `01` --> `00000001`) Usage: ```python from genespeak.utils import DNABaseEncoder encoder = DNABaseEncoder(schema=\"ACGT\") print(encoder.dnabase_as_chr) # {'00':'A', '01':'C', '10':'G', '11':'T'} print(encoder.dnabase_as_bin) # {'A':'00', 'C':'01', 'G':'10', 'T':'11'} ``` There are a total of 24 (`4 x 3 x 2 x 1 = 4!`) possible schemas: `ACGT`, `ACTG`, `AGCT`, `AGTC`, `ATGC`, `ATCG`, `GACT`, `GCAT`, `GCTA`, `AGCT`, etc. \"\"\" dnabase_as_bin : Dict [ str , str ] = DNABASE_AS_BIN . copy () dnabase_as_chr : Dict [ str , str ] = DNABASE_AS_CHR . copy () def __init__ ( self , schema : str = \"AGCT\" , binary_string_length : int = 8 ): conds = [ len ( schema ) != 4 , set ( schema ) != set ( DEFAULT_SCHEMA ), ] self . schema = DEFAULT_SCHEMA if any ( conds ) else schema self . binary_string_length = binary_string_length self . dnabase_as_bin = self . chr2bin . copy () # type: ignore self . dnabase_as_chr = self . bin2chr . copy () # type: ignore @property def bin2chr ( self ) -> Dict [ str , str ]: return dict (( dec2bin ( i ), base ) for i , base in enumerate ( self . schema )) @property def chr2bin ( self ) -> Dict [ str , str ]: return dict (( base , dec2bin ( i )) for i , base in enumerate ( self . schema )) Function dec2bin \u00b6 Converts a single decimal integer to it binary representation and returns as string for length >= n. Source code in genespeak/dna_encoders.py def dec2bin ( x : int , n : int = 2 ) -> str : \"\"\"Converts a single decimal integer to it binary representation and returns as string for length >= n. \"\"\" return str ( int ( bin ( x )[ 2 :])) . zfill ( n )","title":"dna_encoders"},{"location":"api/dna_encoders/#dna-encoders","text":"","title":"DNA Encoders"},{"location":"api/dna_encoders/#class-dnabaseencoder","text":"Bases: object A BaseEncoder class for DNA. Parameters: Name Type Description Default dnabase_as_bin dnabase with char:binary mapping required dnabase_as_chr dnabase with binary:char mapping required schema str the dnabase-schema (default: \"ACGT\") 'AGCT' binary_string_length int the binary-string length to use (example: 01 \u2192 00000001 ) 8 from genespeak.utils import DNABaseEncoder encoder = DNABaseEncoder ( schema = \"ACGT\" ) print ( encoder . dnabase_as_chr ) # {'00':'A', '01':'C', '10':'G', '11':'T'} print ( encoder . dnabase_as_bin ) # {'A':'00', 'C':'01', 'G':'10', 'T':'11'} There are a total of 24 ( 4 x 3 x 2 x 1 = 4! ) possible schemas: ACGT , ACTG , AGCT , AGTC , ATGC , ATCG , GACT , GCAT , GCTA , AGCT , etc. Source code in genespeak/dna_encoders.py class DNABaseEncoder ( object ): \"\"\"A BaseEncoder class for DNA. Arguments: dnabase_as_bin: dnabase with char:binary mapping dnabase_as_chr: dnabase with binary:char mapping schema: the dnabase-schema (default: \"ACGT\") binary_string_length: the binary-string length to use (example: `01` --> `00000001`) Usage: ```python from genespeak.utils import DNABaseEncoder encoder = DNABaseEncoder(schema=\"ACGT\") print(encoder.dnabase_as_chr) # {'00':'A', '01':'C', '10':'G', '11':'T'} print(encoder.dnabase_as_bin) # {'A':'00', 'C':'01', 'G':'10', 'T':'11'} ``` There are a total of 24 (`4 x 3 x 2 x 1 = 4!`) possible schemas: `ACGT`, `ACTG`, `AGCT`, `AGTC`, `ATGC`, `ATCG`, `GACT`, `GCAT`, `GCTA`, `AGCT`, etc. \"\"\" dnabase_as_bin : Dict [ str , str ] = DNABASE_AS_BIN . copy () dnabase_as_chr : Dict [ str , str ] = DNABASE_AS_CHR . copy () def __init__ ( self , schema : str = \"AGCT\" , binary_string_length : int = 8 ): conds = [ len ( schema ) != 4 , set ( schema ) != set ( DEFAULT_SCHEMA ), ] self . schema = DEFAULT_SCHEMA if any ( conds ) else schema self . binary_string_length = binary_string_length self . dnabase_as_bin = self . chr2bin . copy () # type: ignore self . dnabase_as_chr = self . bin2chr . copy () # type: ignore @property def bin2chr ( self ) -> Dict [ str , str ]: return dict (( dec2bin ( i ), base ) for i , base in enumerate ( self . schema )) @property def chr2bin ( self ) -> Dict [ str , str ]: return dict (( base , dec2bin ( i )) for i , base in enumerate ( self . schema ))","title":"Class DNABaseEncoder"},{"location":"api/dna_encoders/#function-dec2bin","text":"Converts a single decimal integer to it binary representation and returns as string for length >= n. Source code in genespeak/dna_encoders.py def dec2bin ( x : int , n : int = 2 ) -> str : \"\"\"Converts a single decimal integer to it binary representation and returns as string for length >= n. \"\"\" return str ( int ( bin ( x )[ 2 :])) . zfill ( n )","title":"Function dec2bin"},{"location":"api/text_strategies/","text":"Text Strategies \u00b6 Class TextEncodingStrategies \u00b6 A class for all available text-encoding strategies. Source code in genespeak/text_strategies.py @dataclass class TextEncodingStrategies : \"\"\"A class for all available text-encoding strategies.\"\"\" ascii = ASCIITextEncodingStrategy () utf8 = UTF8TextEncodingStrategy () Function set_strategy \u00b6 Returns a text-encoding strategy by name. Parameters: Name Type Description Default strategy_name Optional [ str ] name of the text-encoding strategy (options: ascii , utf-8 ) None Source code in genespeak/text_strategies.py def set_strategy ( strategy_name : Optional [ str ] = None ): \"\"\"Returns a text-encoding strategy by name. Arguments: strategy_name: name of the text-encoding strategy (options: ``ascii``, ``utf-8``) \"\"\" if strategy_name : strategy_name = strategy_name . replace ( \"-\" , \"\" ) if ( strategy_name is None ) or ( strategy_name not in AVAILABLE_STRATEGY_NAMES ): strategy_name = DEFAULT_STRATEGY_NAME # The strategy objects don't have any hiphens (\"utf-8\" is written as \"utf8\") return getattr ( TextEncodingStrategies , strategy_name )","title":"text-strategies"},{"location":"api/text_strategies/#text-strategies","text":"","title":"Text Strategies"},{"location":"api/text_strategies/#class-textencodingstrategies","text":"A class for all available text-encoding strategies. Source code in genespeak/text_strategies.py @dataclass class TextEncodingStrategies : \"\"\"A class for all available text-encoding strategies.\"\"\" ascii = ASCIITextEncodingStrategy () utf8 = UTF8TextEncodingStrategy ()","title":"Class TextEncodingStrategies"},{"location":"api/text_strategies/#function-set_strategy","text":"Returns a text-encoding strategy by name. Parameters: Name Type Description Default strategy_name Optional [ str ] name of the text-encoding strategy (options: ascii , utf-8 ) None Source code in genespeak/text_strategies.py def set_strategy ( strategy_name : Optional [ str ] = None ): \"\"\"Returns a text-encoding strategy by name. Arguments: strategy_name: name of the text-encoding strategy (options: ``ascii``, ``utf-8``) \"\"\" if strategy_name : strategy_name = strategy_name . replace ( \"-\" , \"\" ) if ( strategy_name is None ) or ( strategy_name not in AVAILABLE_STRATEGY_NAMES ): strategy_name = DEFAULT_STRATEGY_NAME # The strategy objects don't have any hiphens (\"utf-8\" is written as \"utf8\") return getattr ( TextEncodingStrategies , strategy_name )","title":"Function set_strategy"},{"location":"api/utils/","text":"Utils \u00b6 Run Length Encode \u00b6 Return the run length encoding of a string Usage: dna = \"A\" * 3 + \"G\" * 2 + \"C\" + \"T\" * 5 + \"A\" * 6 + \"GCCT\" dna_rle = run_length_encode ( dna ) Source code in genespeak/utils.py def run_length_encode ( dna : str ) -> str : \"\"\"Return the run length encoding of a string Usage: ```python dna = \"A\"*3 + \"G\"*2 + \"C\" + \"T\"*5 + \"A\"*6 + \"GCCT\" dna_rle = run_length_encode(dna) ``` \"\"\" return _run_length_encode ( dna , use_regex = True , return_list = False ) # type: ignore Run Length Decode \u00b6 Source code in genespeak/utils.py def run_length_decode ( dna_rle : str ) -> str : pat = _PAT_RLE_DECODE return \"\" . join ([ c * int ( n ) for _ , n , c in pat . findall ( dna_rle )])","title":"utils"},{"location":"api/utils/#utils","text":"","title":"Utils"},{"location":"api/utils/#run-length-encode","text":"Return the run length encoding of a string Usage: dna = \"A\" * 3 + \"G\" * 2 + \"C\" + \"T\" * 5 + \"A\" * 6 + \"GCCT\" dna_rle = run_length_encode ( dna ) Source code in genespeak/utils.py def run_length_encode ( dna : str ) -> str : \"\"\"Return the run length encoding of a string Usage: ```python dna = \"A\"*3 + \"G\"*2 + \"C\" + \"T\"*5 + \"A\"*6 + \"GCCT\" dna_rle = run_length_encode(dna) ``` \"\"\" return _run_length_encode ( dna , use_regex = True , return_list = False ) # type: ignore","title":"Run Length Encode"},{"location":"api/utils/#run-length-decode","text":"Source code in genespeak/utils.py def run_length_decode ( dna_rle : str ) -> str : pat = _PAT_RLE_DECODE return \"\" . join ([ c * int ( n ) for _ , n , c in pat . findall ( dna_rle )])","title":"Run Length Decode"},{"location":"assets/css-js/termynal/readme/","text":"Termynal : Terminal Animation \u00b6 Just copy and paste the terminal folder in a docs/assests folder and then add the following snippet to your mkdocs.yml . ```yaml for terminal animation \u00b6 extra_css: - assets/termynal/css/termynal.css - assets/termynal/css/custom.css extra_javascript: - assets/termynal/js/termynal.js - assets/termynal/js/custom.js ``","title":"**Termynal**: Terminal Animation"},{"location":"assets/css-js/termynal/readme/#termynal-terminal-animation","text":"Just copy and paste the terminal folder in a docs/assests folder and then add the following snippet to your mkdocs.yml . ```yaml","title":"Termynal: Terminal Animation"},{"location":"assets/css-js/termynal/readme/#for-terminal-animation","text":"extra_css: - assets/termynal/css/termynal.css - assets/termynal/css/custom.css extra_javascript: - assets/termynal/js/termynal.js - assets/termynal/js/custom.js ``","title":"for terminal animation"},{"location":"assets/snippets/notifications/videos/disclaimer/","text":"Disclaimer This library is currently under rapid initial development. Breaking changes may happen frequently.","title":"Disclaimer"},{"location":"quickstart/","text":"Quickstart \u00b6 See the quickstart guide here. Service Link/Badge Colab Binder SageMaker StudioLab","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"See the quickstart guide here. Service Link/Badge Colab Binder SageMaker StudioLab","title":"Quickstart"},{"location":"quickstart/faq/","text":"","title":"FAQ"}]}